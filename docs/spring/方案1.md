方案二的核心是 Client 传输「实体元信息+操作指令+数据」的 JSON，而非直接传 SQL，Server 端通过解析这些信息动态生成 SQL 并执行，全程不需要依赖 Client 的实体类，完全满足「Server 零改动」的需求。
 
以下是可落地的完整实现方案，包含 DTO 设计、Client 封装逻辑、Server 动态 SQL 构建、结果返回全流程。
 
 
 
核心设计思路
 
1. 统一交互协议：定义通用 JSON 请求体，包含 操作类型（CRUD）、实体元信息（表名/字段）、条件/数据 三大核心部分。
2. Client 端：通过反射读取  @Entity  注解的实体类，提取表名、字段名、字段类型，封装成协议请求。
3. Server 端：解析请求体，根据操作类型动态拼接 参数化 SQL（避免注入），执行后返回标准化 JSON 结果。
4. Client 端：将 Server 返回的 JSON 结果反序列化为自己的实体类对象。
 
 
 
第一步：定义通用交互 DTO（Client 和 Server 共用）
 
需要创建 3 个核心 DTO 类（Client 和 Server 都要引入，可抽成独立的  common  模块），用于 JSON 序列化/反序列化。
 
1.  操作类型枚举  SqlOperationType 
 
java  
public enum SqlOperationType {
    SELECT, INSERT, UPDATE, DELETE, CREATE_TABLE
}
 
 
2.  查询条件 DTO  Condition 
 
用于封装查询条件（如  age > 18 、 name = '张三' ）
 
java  
public class Condition {
    private String field;       // 实体字段名（如 username）
    private String operator;    // 操作符（EQ/GT/LT/LIKE 等）
    private Object value;       // 条件值（如 18、张三）

    // Getters & Setters
}
 
 
3.  核心请求 DTO  JpaEntityRequest 
 
java  
public class JpaEntityRequest {
    // 1. 操作类型
    private SqlOperationType operationType;

    // 2. 实体元信息（Server 不需要实体类，靠这些信息映射表和字段）
    private String tableName;                       // 表名（来自 @Table 注解）
    private Map<String, String> fieldColumnMap;     // 实体字段名 → 数据库列名（来自 @Column 注解）
    private Map<String, String> fieldTypeMap;       // 实体字段名 → Java 类型全限定名（如 java.lang.String）
    private String idField;                         // 主键字段名（用于 UPDATE/DELETE）

    // 3. 操作参数
    private List<Condition> conditions;             // 查询条件（SELECT/DELETE 用）
    private Map<String, Object> entityData;         // 实体数据（INSERT/UPDATE 用）
    private Integer limit;                          // 分页限制（SELECT 用）

    // Getters & Setters
}
 
 
4.  通用响应 DTO  SqlResponse 
 
java  
public class SqlResponse {
    private boolean success;
    private String message;
    private List<Map<String, Object>> data;         // 查询结果集
    private Long affectedRows;                      // 受影响行数（INSERT/UPDATE/DELETE 用）

    // Getters & Setters & 构造器
    public static SqlResponse success(List<Map<String, Object>> data) {
        return new SqlResponse(true, "操作成功", data, null);
    }

    public static SqlResponse success(Long affectedRows) {
        return new SqlResponse(true, "操作成功", null, affectedRows);
    }

    public static SqlResponse fail(String message) {
        return new SqlResponse(false, message, null, null);
    }
}
 
 
 
 
第二步：Client 端 - 封装请求（核心）
 
Client 端的核心是 通过反射读取  @Entity  实体类的元信息，并封装成  JpaEntityRequest 。
 
1.  反射工具类  JpaEntityMetaUtils （Client 端用）
 
用于提取实体类的表名、字段、主键等元信息：
 
java  
import javax.persistence.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class JpaEntityMetaUtils {

    /**
     * 提取实体类的元信息（表名、字段-列名映射、字段-类型映射、主键字段）
     */
    public static <T> Map<String, Object> extractEntityMeta(Class<T> entityClass) {
        Map<String, Object> metaMap = new HashMap<>();

        // 1. 获取表名（优先 @Table 注解，否则用类名小写）
        Table tableAnnotation = entityClass.getAnnotation(Table.class);
        String tableName = tableAnnotation != null ? tableAnnotation.name() : entityClass.getSimpleName().toLowerCase();
        metaMap.put("tableName", tableName);

        // 2. 获取字段-列名映射、字段-类型映射
        Map<String, String> fieldColumnMap = new HashMap<>();
        Map<String, String> fieldTypeMap = new HashMap<>();
        String idField = null;

        for (Field field : entityClass.getDeclaredFields()) {
            String fieldName = field.getName();
            // 列名：优先 @Column 注解，否则用字段名小写
            Column columnAnnotation = field.getAnnotation(Column.class);
            String columnName = columnAnnotation != null ? columnAnnotation.name() : fieldName.toLowerCase();
            fieldColumnMap.put(fieldName, columnName);

            // 字段类型：保存全限定名
            fieldTypeMap.put(fieldName, field.getType().getName());

            // 主键字段
            if (field.isAnnotationPresent(Id.class)) {
                idField = fieldName;
            }
        }

        metaMap.put("fieldColumnMap", fieldColumnMap);
        metaMap.put("fieldTypeMap", fieldTypeMap);
        metaMap.put("idField", idField);
        return metaMap;
    }
}
 
 
2.  Client 端请求封装工具  JpaRequestBuilder 
 
用于构建  JpaEntityRequest ，支持 CRUD 操作：
 
java  
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JpaRequestBuilder {

    // 构建查询请求
    public static <T> JpaEntityRequest buildSelectRequest(Class<T> entityClass, List<Condition> conditions, Integer limit) {
        JpaEntityRequest request = new JpaEntityRequest();
        fillEntityMeta(request, entityClass);
        request.setOperationType(SqlOperationType.SELECT);
        request.setConditions(conditions);
        request.setLimit(limit);
        return request;
    }

    // 构建新增请求
    public static <T> JpaEntityRequest buildInsertRequest(T entity) {
        JpaEntityRequest request = new JpaEntityRequest();
        Class<T> entityClass = (Class<T>) entity.getClass();
        fillEntityMeta(request, entityClass);
        request.setOperationType(SqlOperationType.INSERT);

        // 提取实体数据
        Map<String, Object> entityData = new HashMap<>();
        for (Field field : entityClass.getDeclaredFields()) {
            field.setAccessible(true);
            try {
                entityData.put(field.getName(), field.get(entity));
            } catch (IllegalAccessException e) {
                throw new RuntimeException("提取实体数据失败", e);
            }
        }
        request.setEntityData(entityData);
        return request;
    }

    // 填充实体元信息
    private static <T> void fillEntityMeta(JpaEntityRequest request, Class<T> entityClass) {
        Map<String, Object> metaMap = JpaEntityMetaUtils.extractEntityMeta(entityClass);
        request.setTableName((String) metaMap.get("tableName"));
        request.setFieldColumnMap((Map<String, String>) metaMap.get("fieldColumnMap"));
        request.setFieldTypeMap((Map<String, String>) metaMap.get("fieldTypeMap"));
        request.setIdField((String) metaMap.get("idField"));
    }

    // 同理可实现 buildUpdateRequest、buildDeleteRequest、buildCreateTableRequest
}
 
 
3.  Client 端发送请求示例
 
以查询  CustomUser  为例：
 
java  
// 1. 定义 Client 端的实体类
@Entity
@Table(name = "custom_user")
public class CustomUser {
    @Id
    @Column(name = "user_id")
    private Long id;
    @Column(name = "user_name")
    private String username;
    private Integer age;
    // Getters & Setters
}

// 2. 构建查询条件
List<Condition> conditions = List.of(new Condition("age", "GT", 18));

// 3. 构建请求
JpaEntityRequest request = JpaRequestBuilder.buildSelectRequest(CustomUser.class, conditions, 10);

// 4. 发送 HTTP 请求（用 RestTemplate/OkHttp 等）
RestTemplate restTemplate = new RestTemplate();
SqlResponse response = restTemplate.postForObject(
    "http://server-host:port/execute/entity",
    request,
    SqlResponse.class
);

// 5. 将返回的 JSON 结果反序列化为 Client 端实体类
if (response.isSuccess()) {
    ObjectMapper objectMapper = new ObjectMapper();
    List<CustomUser> users = objectMapper.convertValue(
        response.getData(),
        new TypeReference<List<CustomUser>>() {}
    );
}
 
 
 
 
第三步：Server 端 - 动态解析请求并生成 SQL
 
Server 端的核心是 解析  JpaEntityRequest ，动态拼接参数化 SQL，通过  JdbcTemplate  执行，全程不依赖 Client 实体类。
 
1.  Server 端核心工具：动态 SQL 构建器  DynamicSqlBuilder 
 
java  
import org.springframework.util.StringUtils;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class DynamicSqlBuilder {

    // 操作符映射（Client 端的 operator → SQL 操作符）
    private static final Map<String, String> OPERATOR_MAP = Map.of(
        "EQ", "=",
        "GT", ">",
        "LT", "<",
        "LIKE", "LIKE"
    );

    /**
     * 根据请求生成 SQL 和参数列表（参数化查询，防注入）
     */
    public static SqlAndParams buildSql(JpaEntityRequest request) {
        return switch (request.getOperationType()) {
            case SELECT -> buildSelectSql(request);
            case INSERT -> buildInsertSql(request);
            case UPDATE -> buildUpdateSql(request);
            case DELETE -> buildDeleteSql(request);
            case CREATE_TABLE -> buildCreateTableSql(request);
        };
    }

    // 构建 SELECT SQL
    private static SqlAndParams buildSelectSql(JpaEntityRequest request) {
        StringBuilder sql = new StringBuilder("SELECT ");
        List<Object> params = new ArrayList<>();

        // 1. 拼接列名（fieldColumnMap: 实体字段→列名）
        Map<String, String> fieldColumnMap = request.getFieldColumnMap();
        List<String> columns = new ArrayList<>(fieldColumnMap.values());
        sql.append(String.join(", ", columns)).append(" FROM ").append(request.getTableName());

        // 2. 拼接 WHERE 条件
        List<Condition> conditions = request.getConditions();
        if (conditions != null && !conditions.isEmpty()) {
            sql.append(" WHERE ");
            List<String> conditionSql = new ArrayList<>();
            for (Condition cond : conditions) {
                String column = fieldColumnMap.get(cond.getField());
                String operator = OPERATOR_MAP.getOrDefault(cond.getOperator(), "=");
                conditionSql.add(column + " " + operator + " ?");
                params.add(cond.getValue());
            }
            sql.append(String.join(" AND ", conditionSql));
        }

        // 3. 拼接 LIMIT
        if (request.getLimit() != null) {
            sql.append(" LIMIT ?");
            params.add(request.getLimit());
        }

        return new SqlAndParams(sql.toString(), params);
    }

    // 构建 INSERT SQL（同理，省略 UPDATE/DELETE/CREATE_TABLE 的实现）
    private static SqlAndParams buildInsertSql(JpaEntityRequest request) {
        // 核心逻辑：提取 entityData 中的字段→值，拼接 INSERT INTO table (cols) VALUES (?)
        return null;
    }

    // 内部类：封装 SQL 语句和参数列表
    public static class SqlAndParams {
        private String sql;
        private List<Object> params;

        public SqlAndParams(String sql, List<Object> params) {
            this.sql = sql;
            this.params = params;
        }
        // Getters
    }
}
 
 
2.  Server 端 Controller 实现
 
java  
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;
import java.util.Map;

@RestController
public class JpaEntityExecuteController {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @PostMapping("/execute/entity")
    public SqlResponse executeEntity(@RequestBody JpaEntityRequest request) {
        try {
            // 1. 动态生成 SQL 和参数
            DynamicSqlBuilder.SqlAndParams sqlAndParams = DynamicSqlBuilder.buildSql(request);
            String sql = sqlAndParams.getSql();
            List<Object> params = sqlAndParams.getParams();

            // 2. 根据操作类型执行 SQL
            return switch (request.getOperationType()) {
                case SELECT -> {
                    List<Map<String, Object>> result = jdbcTemplate.queryForList(sql, params.toArray());
                    yield SqlResponse.success(result);
                }
                case INSERT, UPDATE, DELETE -> {
                    int affectedRows = jdbcTemplate.update(sql, params.toArray());
                    yield SqlResponse.success((long) affectedRows);
                }
                case CREATE_TABLE -> {
                    jdbcTemplate.execute(sql);
                    yield SqlResponse.success("表创建成功");
                }
            };
        } catch (Exception e) {
            return SqlResponse.fail("操作失败：" + e.getMessage());
        }
    }
}
 
 
 
 
关键注意事项
 
1. 安全性（重中之重）
- 必须使用 参数化 SQL（ ?  占位符），杜绝 SQL 注入；
- Server 端需加权限控制，限制允许操作的表和字段；
- 禁止 Client 端发送  DROP / ALTER  等高危操作。
2. 类型映射兼容性
- 需维护 Java 类型 → SQL 类型 的映射表（如  java.lang.String  →  VARCHAR ），用于  CREATE_TABLE  场景；
- Server 端返回的结果值类型需与 Client 实体类字段类型匹配，避免反序列化失败。
3. 扩展性
- 可在  Condition  中增加  logic  字段（ AND / OR ），支持复杂多条件查询；
- 支持分页参数（ offset / pageSize ）、排序参数（ orderBy ）。
 
 
 
我可以帮你编写 完整的 Client 端 CRUD 示例代码，包含新增、修改、删除的请求构建逻辑，需要吗？