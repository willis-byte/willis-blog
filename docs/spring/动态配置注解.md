好，我明白你想要的是：
 
1. 本地快取（Local Cache）：當 API 調用失敗時，使用上次成功的值。
2. 更新信號（Update Signal）：當屬性真係被更新時，觸發一個回調或事件，通知你做後續處理。
 
我會俾你一套 完整、可直接使用 的程式碼，包含：
 
- 自定義注解  @DynamicConfig 
- 本地快取（基於 Guava Cache 或 ConcurrentHashMap）
- 屬性更新事件（ApplicationEvent）
- 事件監聽器（EventListener）
- 定時任務拉取 API
- 自動類型轉換（支援基本類型 + 物件）
 
 
 
一、最終效果
 
1. 使用注解
 
java  
@Component
public class MyService {

    @DynamicConfig(url = "http://localhost:8080/api/config/maxRetry", refreshRate = 5000)
    private Integer maxRetry;

    // 當 maxRetry 被更新時，會自動呼叫呢個方法
    @ConfigUpdateListener(fieldName = "maxRetry")
    public void onMaxRetryUpdate(Integer oldValue, Integer newValue) {
        System.out.println("收到信號：maxRetry 從 " + oldValue + " 變成 " + newValue);
        // 在這裡寫你的業務邏輯，例如重新初始化連接池、刷新配置等
    }
}
 
 
2. 本地快取
 
當 API 宕機或返回錯誤時，不會改變當前值，也不會報錯，直接使用快取中的舊值。
 
 
 
二、依賴（如果你用 Guava Cache）
 
xml  
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>32.1.3-jre</version>
</dependency>
 
 
 
 
三、完整程式碼
 
1. 自定義事件（用於發送信號）
 
java  
import org.springframework.context.ApplicationEvent;

public class ConfigUpdateEvent<T> extends ApplicationEvent {

    private final String beanName;
    private final String fieldName;
    private final T oldValue;
    private final T newValue;

    public ConfigUpdateEvent(Object source, String beanName, String fieldName, T oldValue, T newValue) {
        super(source);
        this.beanName = beanName;
        this.fieldName = fieldName;
        this.oldValue = oldValue;
        this.newValue = newValue;
    }

    // Getters
    public String getBeanName() { return beanName; }
    public String getFieldName() { return fieldName; }
    public T getOldValue() { return oldValue; }
    public T getNewValue() { return newValue; }
}
 
 
2. 自定義注解（配置 API 和刷新頻率）
 
java  
import java.lang.annotation.*;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DynamicConfig {
    String url();
    long refreshRate() default 5000; // 預設 5 秒
}
 
 
3. 自定義注解（標記回調方法）
 
java  
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ConfigUpdateListener {
    String fieldName(); // 指定監聽哪個屬性
}
 
 
4. 核心處理器（掃描注解 + 定時拉取 + 快取 + 發送信號）
 
java  
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Component
public class DynamicConfigProcessor implements BeanPostProcessor {

    private final RestTemplate restTemplate = new RestTemplate();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(5);
    private final ApplicationEventPublisher eventPublisher;
    private final ApplicationContext applicationContext;

    // 本地快取：Key = beanName + fieldName, Value = 最新值
    private final Cache<String, Object> localCache = CacheBuilder.newBuilder()
            .expireAfterWrite(1, TimeUnit.HOURS)
            .build();

    @Autowired
    public DynamicConfigProcessor(ApplicationEventPublisher eventPublisher, ApplicationContext applicationContext) {
        this.eventPublisher = eventPublisher;
        this.applicationContext = applicationContext;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        Class<?> clazz = bean.getClass();

        // 1. 處理 @DynamicConfig 屬性
        processConfigFields(bean, beanName, clazz);

        // 2. 註冊 @ConfigUpdateListener 方法 (這裡簡化處理，實際可使用 AOP 或事件監聽)
        // 這裡我們先把邏輯放在屬性更新時直接透過反射呼叫，或者你可以用 Spring Event 機制

        return bean;
    }

    private void processConfigFields(Object bean, String beanName, Class<?> clazz) {
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(DynamicConfig.class)) {
                DynamicConfig anno = field.getAnnotation(DynamicConfig.class);
                String url = anno.url();
                long rate = anno.refreshRate();

                // 初始化時先拉取一次
                fetchAndUpdate(bean, beanName, field, url);

                // 定時拉取
                scheduler.scheduleAtFixedRate(() -> {
                    fetchAndUpdate(bean, beanName, field, url);
                }, rate, rate, TimeUnit.MILLISECONDS);
            }
        }
    }

    private void fetchAndUpdate(Object bean, String beanName, Field field, String url) {
        try {
            Class<?> fieldType = field.getType();
            Object apiValue = null;

            // 1. 呼叫 API (帶有簡單的異常處理)
            try {
                apiValue = restTemplate.getForObject(url, fieldType);
            } catch (Exception e) {
                System.err.println("API 調用失敗，使用本地快取。URL: " + url);
                // API 失敗，嘗試從快取獲取舊值
                apiValue = localCache.getIfPresent(getCacheKey(beanName, field.getName()));
                if (apiValue == null) {
                    System.err.println("本地快取亦無數據，屬性保持不變。");
                    return;
                }
            }

            // 2. 如果 API 返回 null，使用快取舊值
            if (apiValue == null) {
                apiValue = localCache.getIfPresent(getCacheKey(beanName, field.getName()));
                if (apiValue == null) return;
            }

            field.setAccessible(true);
            Object oldValue = field.get(bean);

            // 3. 如果值有變化，才更新並發送信號
            if ((oldValue == null && apiValue != null) || (oldValue != null && !oldValue.equals(apiValue))) {
                field.set(bean, apiValue);
                localCache.put(getCacheKey(beanName, field.getName()), apiValue);

                System.out.println("屬性已更新: " + beanName + "." + field.getName() + " = " + apiValue);

                // 4. 發送 Spring 事件 (信號)
                eventPublisher.publishEvent(new ConfigUpdateEvent<>(this, beanName, field.getName(), oldValue, apiValue));

                // 5. (可選) 直接透過反射呼叫 bean 內部的回調方法
                invokeLocalListener(bean, field.getName(), oldValue, apiValue);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // 生成快取 Key
    private String getCacheKey(String beanName, String fieldName) {
        return beanName + ":" + fieldName;
    }

    // 尋找並呼叫 @ConfigUpdateListener 標記的方法
    private void invokeLocalListener(Object bean, String fieldName, Object oldValue, Object newValue) {
        try {
            for (Method method : bean.getClass().getDeclaredMethods()) {
                if (method.isAnnotationPresent(ConfigUpdateListener.class)) {
                    ConfigUpdateListener anno = method.getAnnotation(ConfigUpdateListener.class);
                    if (anno.fieldName().equals(fieldName)) {
                        method.setAccessible(true);
                        // 假設方法簽名是 void method(Object old, Object new)
                        method.invoke(bean, oldValue, newValue);
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
 
 
5. 全域事件監聽器（如果你想在其他地方監聽）
 
java  
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
public class GlobalConfigListener {

    // 監聽所有配置更新
    @EventListener
    public void handleConfigUpdate(ConfigUpdateEvent<?> event) {
        System.out.println("[全域監聽] 收到更新信號: " + event.getBeanName() + "." + event.getFieldName() +
                " -> " + event.getNewValue());
    }
}
 
 
 
 
四、使用範例
 
java  
import org.springframework.stereotype.Component;

@Component
public class TestService {

    // 動態配置屬性
    @DynamicConfig(url = "http://localhost:8080/api/config/maxRetry", refreshRate = 3000)
    private Integer maxRetry;

    // 內部回調 (方式一)
    @ConfigUpdateListener(fieldName = "maxRetry")
    public void onConfigChange(Integer oldVal, Integer newVal) {
        System.out.println("[內部回調] maxRetry 變更: " + oldVal + " -> " + newVal);
        // 這裡寫你的業務邏輯
    }
}
 
 
 
 
五、程式碼解釋
 
1. 本地快取：使用了  Guava Cache  來存儲每個屬性的最新有效值。當 API 失敗時， fetchAndUpdate  會先嘗試從  localCache  讀取，如果讀取不到，屬性保持不變。
2. 更新信號：
- 方式一（推薦）：透過  ApplicationEventPublisher  發布  ConfigUpdateEvent 。你可以在任何  @Component  中使用  @EventListener  來接收這個事件。
- 方式二（簡單）：在  fetchAndUpdate  中透過反射  invokeLocalListener ，直接呼叫當前 Bean 內部被  @ConfigUpdateListener  標註的方法。
3. 類型安全：程式碼會自動根據  Field  的類型去轉換 API 返回的 JSON 數據。
 
 
 
六、如果你需要加強
 
1. 支援 JSON 物件：目前程式碼已經支援，只要 API 返回 JSON， RestTemplate  會自動轉換成對應的 Class。
2. 支援加密/解密：在  fetchAndUpdate  中加入解密邏輯。
3. 支援配置中心（Nacos/Apollo）：把  RestTemplate  替換成 Nacos/Apollo 的 Client SDK 即可。
 
這套程式碼你可以直接複製到項目中使用！